#!/bin/sh
# Auto-generated by branding generator. Do not edit directly.
# Source: tools/branding/templates/services/runtime-node/entrypoint.common.sh.tmpl
# Where: services/runtime-node/entrypoint.common.sh
# What: Shared helpers for runtime-node entrypoints.
# Why: Keep containerd/firecracker startup logic consistent.

log_info() {
  echo "INFO: $*"
}

log_warn() {
  echo "WARN: $*" >&2
}

log_error() {
  echo "ERROR: $*" >&2
}

setup_cgroupv2_delegation() {
  if [ "{{ENV_PREFIX_VAR}}_CGROUP_DELEGATION:-1}" = "0" ]; then
    log_info "Cgroup delegation disabled ({{ENV_PREFIX}}_CGROUP_DELEGATION=0)"
    return 0
  fi
  if [ ! -f /sys/fs/cgroup/cgroup.controllers ]; then
    log_info "Cgroup v2 not detected; skipping delegation"
    return 0
  fi

  root_dir="/sys/fs/cgroup"
  parent_name="{{ENV_PREFIX_VAR}}_CGROUP_PARENT:-{{RUNTIME_CGROUP_PARENT}}}"
  leaf_name="{{ENV_PREFIX_VAR}}_CGROUP_LEAF:-{{RUNTIME_CGROUP_LEAF}}}"
  controllers="{{ENV_PREFIX_VAR}}_CGROUP_CONTROLLERS:-cpu io memory pids}"

  if [ -z "$parent_name" ] || [ -z "$leaf_name" ]; then
    log_error "{{ENV_PREFIX}}_CGROUP_PARENT and {{ENV_PREFIX}}_CGROUP_LEAF must be set"
    exit 1
  fi

  parent_name="${parent_name#/}"
  leaf_name="${leaf_name#/}"
  parent_dir="${root_dir}/${parent_name}"
  leaf_dir="${parent_dir}/${leaf_name}"

  mkdir -p "$parent_dir" "$leaf_dir"

  current_cgroup="$(awk -F: '$1 == "0" {print $3}' /proc/1/cgroup 2>/dev/null || true)"
  if [ -z "$current_cgroup" ]; then
    current_cgroup="$(awk -F: '$1 == "0" {print $3}' /proc/self/cgroup 2>/dev/null || true)"
  fi
  if [ -z "$current_cgroup" ]; then
    current_cgroup="/"
  fi
  if [ "$current_cgroup" = "/" ]; then
    current_dir="$root_dir"
  else
    current_dir="${root_dir}${current_cgroup}"
  fi

  move_procs_from() {
    src_dir="$1"
    if [ ! -f "${src_dir}/cgroup.procs" ]; then
      return 0
    fi
    while read -r pid; do
      if [ -z "$pid" ]; then
        continue
      fi
      if ! echo "$pid" > "${leaf_dir}/cgroup.procs"; then
        log_error "Failed to move pid ${pid} to ${leaf_dir}"
        return 1
      fi
    done < "${src_dir}/cgroup.procs"
    return 0
  }

  for _ in 1 2 3; do
    if [ "$current_dir" != "$leaf_dir" ]; then
      move_procs_from "$current_dir" || exit 1
    fi
    if [ "$parent_dir" != "$leaf_dir" ]; then
      move_procs_from "$parent_dir" || exit 1
    fi
    if [ "$root_dir" != "$leaf_dir" ]; then
      move_procs_from "$root_dir" || exit 1
    fi
    if [ ! -s "${parent_dir}/cgroup.procs" ]; then
      break
    fi
    sleep 0.1
  done

  if [ -s "${parent_dir}/cgroup.procs" ]; then
    log_error "Cgroup parent still has processes: ${parent_dir}"
    cat "${parent_dir}/cgroup.procs" || true
    exit 1
  fi

  available="$(cat "${parent_dir}/cgroup.controllers" 2>/dev/null || true)"
  missing=0
  for ctl in $controllers; do
    if ! echo "$available" | grep -qw "$ctl"; then
      missing=1
      break
    fi
  done

  if [ "$missing" = "1" ]; then
    if [ -s "${root_dir}/cgroup.procs" ]; then
      log_error "Cgroup root still has processes; cannot enable controllers on ${root_dir}"
      cat "${root_dir}/cgroup.procs" || true
      exit 1
    fi
    root_available="$(cat "${root_dir}/cgroup.controllers" 2>/dev/null || true)"
    for ctl in $controllers; do
      if echo "$root_available" | grep -qw "$ctl"; then
        if ! echo "+$ctl" > "${root_dir}/cgroup.subtree_control"; then
          log_error "Failed to enable controller ${ctl} on ${root_dir}"
          exit 1
        fi
      else
        log_error "Controller ${ctl} not available on ${root_dir}"
        exit 1
      fi
    done
    available="$(cat "${parent_dir}/cgroup.controllers" 2>/dev/null || true)"
  fi

  for ctl in $controllers; do
    if echo "$available" | grep -qw "$ctl"; then
      if ! echo "+$ctl" > "${parent_dir}/cgroup.subtree_control"; then
        log_error "Failed to enable controller ${ctl} on ${parent_dir}"
        exit 1
      fi
    else
      log_error "Controller ${ctl} not available on ${parent_dir}"
      exit 1
    fi
  done

  if echo "$controllers" | grep -qw "memory"; then
    if ! grep -qw "memory" "${parent_dir}/cgroup.subtree_control"; then
      log_error "Memory controller not enabled on ${parent_dir}"
      exit 1
    fi
  fi

  if [ -f "${parent_dir}/cgroup.type" ]; then
    cgroup_type="$(cat "${parent_dir}/cgroup.type")"
    if [ "$cgroup_type" != "domain" ]; then
      log_error "Cgroup parent type is ${cgroup_type} (expected domain)"
      exit 1
    fi
  fi

  log_info "Cgroup v2 delegation configured (parent=${parent_dir} leaf=${leaf_dir} controllers=${controllers})"
}

ensure_ip_forward() {
  if [ -w /proc/sys/net/ipv4/ip_forward ]; then
    echo 1 > /proc/sys/net/ipv4/ip_forward
  fi
}

ensure_route_localnet() {
  for path in \
    /proc/sys/net/ipv4/conf/all/route_localnet \
    /proc/sys/net/ipv4/conf/default/route_localnet \
    /proc/sys/net/ipv4/conf/lo/route_localnet; do
    if [ -w "$path" ]; then
      echo 1 > "$path"
    fi
  done
}

ensure_hv_network() {
  if ! command -v ethtool >/dev/null 2>&1; then
    return
  fi
  if ip link show eth0 >/dev/null 2>&1; then
    ethtool -K eth0 tx-checksumming off >/dev/null 2>&1 || true
  fi
}

ensure_wg_route() {
  if [ -z "${WG_CONTROL_NET:-}" ]; then
    return
  fi
  gw="${WG_CONTROL_GW:-}"
  if [ -z "$gw" ] && [ -n "${WG_CONTROL_GW_HOST:-}" ]; then
    gw="$(getent hosts "$WG_CONTROL_GW_HOST" 2>/dev/null | awk '{print $1}' | head -n1)"
  fi
  if [ -z "$gw" ]; then
    gw="$(ip route show default 0.0.0.0/0 2>/dev/null | awk '{print $3}' | head -n1)"
  fi
  if [ -z "$gw" ]; then
    log_warn "default gateway not found; skipping WG route for ${WG_CONTROL_NET}"
    return
  fi
  ip route replace "$WG_CONTROL_NET" via "$gw" 2>/dev/null || true
}

start_wg_route_watcher() {
  if [ -z "${WG_CONTROL_NET:-}" ] || [ -z "${WG_CONTROL_GW_HOST:-}" ] || [ -n "${WG_CONTROL_GW:-}" ]; then
    return
  fi
  (
    for _ in $(seq 1 30); do
      gw="$(getent hosts "$WG_CONTROL_GW_HOST" 2>/dev/null | awk '{print $1}' | head -n1)"
      if [ -n "$gw" ]; then
        ip route replace "$WG_CONTROL_NET" via "$gw" 2>/dev/null || true
        exit 0
      fi
      sleep 1
    done
  ) &
}

ensure_vhost_vsock() {
  if [ -e /dev/vhost-vsock ]; then
    return
  fi
  log_warn "/dev/vhost-vsock is missing. Load vhost_vsock on the host to enable vsock."
  if [ "${VHOST_VSOCK_REQUIRED:-0}" = "1" ]; then
    log_error "/dev/vhost-vsock is required but missing."
    exit 1
  fi
}

start_udevd() {
  if [ "${DEVMAPPER_UDEV:-0}" != "1" ]; then
    return
  fi
  if ! command -v udevadm >/dev/null 2>&1 && [ ! -x /lib/systemd/systemd-udevd ] && ! command -v udevd >/dev/null 2>&1; then
    log_warn "udev not available; devmapper may fail"
    return
  fi
  mkdir -p /run/udev
  if command -v udevd >/dev/null 2>&1; then
    udevd --daemon || true
  elif [ -x /lib/systemd/systemd-udevd ]; then
    /lib/systemd/systemd-udevd --daemon || true
  fi
  if command -v udevadm >/dev/null 2>&1; then
    udevadm trigger --action=add >/dev/null 2>&1 || true
    udevadm settle >/dev/null 2>&1 || true
  fi
}

start_firecracker_fifo_reader() {
  if [ "${FIRECRACKER_FIFO_READER:-1}" != "1" ]; then
    return
  fi
  fifo_root="/var/lib/firecracker-containerd/shim-base"
  state_dir="/run/firecracker-fifo-readers"
  mkdir -p "$state_dir"

  (
    while true; do
      if [ -d "$fifo_root" ]; then
        find "$fifo_root" -type p -name 'fc-*.fifo' 2>/dev/null | while read -r fifo; do
          key=$(echo "$fifo" | tr '/' '_')
          marker="$state_dir/$key"
          if [ ! -f "$marker" ]; then
            touch "$marker"
            (cat "$fifo" >/dev/null 2>&1 &) || true
          fi
        done
      fi
      sleep 0.2
    done
  ) &
}

ensure_devmapper_ready() {
  if [ -z "${DEVMAPPER_POOL:-}" ]; then
    return
  fi
  if ! command -v dmsetup >/dev/null 2>&1; then
    log_warn "dmsetup not found; skipping devmapper check"
    return
  fi

  dm_env="DM_UDEV_DISABLE=1 DM_UDEV_DISABLE_DISK_RULES_FLAG=1"
  if [ "${DEVMAPPER_UDEV:-0}" = "1" ]; then
    dm_env=""
  fi

  if ! env $dm_env dmsetup status "$DEVMAPPER_POOL" >/dev/null 2>&1; then
    log_error "Devmapper pool ${DEVMAPPER_POOL} is missing. Run {{CLI_NAME}} node provision."
    exit 1
  fi

  env $dm_env dmsetup mknodes "$DEVMAPPER_POOL" >/dev/null 2>&1 || true
  if [ ! -e "/dev/mapper/$DEVMAPPER_POOL" ]; then
    tries=10
    while [ "$tries" -gt 0 ] && [ ! -e "/dev/mapper/$DEVMAPPER_POOL" ]; do
      dmsetup mknodes "$DEVMAPPER_POOL" >/dev/null 2>&1 || true
      sleep 0.2
      tries=$((tries - 1))
    done
  fi
}

start_devmapper_watcher() {
  if [ -z "${DEVMAPPER_POOL:-}" ]; then
    return
  fi
  if [ "${DEVMAPPER_UDEV:-0}" = "1" ]; then
    return
  fi
  if ! command -v dmsetup >/dev/null 2>&1; then
    return
  fi

  (
    while true; do
      for dev in $(dmsetup ls --noheadings 2>/dev/null | awk '{print $1}'); do
        case "$dev" in
          "${DEVMAPPER_POOL}-snap-"*)
            if [ ! -e "/dev/mapper/$dev" ]; then
              dmsetup mknodes "$dev" >/dev/null 2>&1 || true
            fi
            ;;
        esac
      done
      sleep 0.5
    done
  ) &
}

apply_cni_nat() {
  # Ensure SNAT/MASQUERADE for CNI subnet traffic exiting to external networks.
  ensure_iptables_rule nat POSTROUTING -s 10.88.0.0/16 ! -d 10.88.0.0/16 -j MASQUERADE
  # Allow forwarding between the CNI bridge and external interfaces.
  ensure_iptables_rule filter FORWARD -i {{RUNTIME_CNI_BRIDGE}} -j ACCEPT
  ensure_iptables_rule filter FORWARD -o {{RUNTIME_CNI_BRIDGE}} -j ACCEPT
}

ensure_iptables_rule() {
  table="$1"
  shift
  if iptables -t "$table" -C "$@" >/dev/null 2>&1; then
    return
  fi
  iptables -t "$table" -A "$@"
}

start_containerd() {
  if [ -n "${CONTAINERD_CONFIG:-}" ]; then
    exec "$CONTAINERD_BIN" --config "$CONTAINERD_CONFIG" --address /run/containerd/containerd.sock
  fi
  exec "$CONTAINERD_BIN" --address /run/containerd/containerd.sock
}
